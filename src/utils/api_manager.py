"""
API key management with encryption.

Security features:
- Random salt per installation (stored in config)
- Machine-bound encryption with secure fallback
- File permissions restricted to current user
"""
import json
import logging
import uuid
import os
import stat
import secrets
import httpx
from pathlib import Path

logger = logging.getLogger(__name__)
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
from typing import Optional

from config import CONFIG_FILE, API_TIMEOUT, DEEPGRAM_DEFAULT_MODEL, DEEPGRAM_DEFAULT_SPECIALIZATION

# Salt length in bytes (256 bits)
SALT_LENGTH = 32


class APIManager:
    """Manages Deepgram API key storage and validation."""

    def __init__(self):
        self._fernet = None  # Lazy initialization

    def _get_machine_id(self) -> str:
        """Get a unique machine identifier with secure fallback."""
        try:
            # Try to get MAC address
            node = uuid.getnode()
            # Check if it's a real MAC (not randomly generated by uuid)
            # Random MACs have the multicast bit set
            if (node >> 40) & 1:
                raise ValueError("Random MAC detected")
            machine_id = str(node)
        except Exception:
            # Secure fallback: generate and persist a random machine ID
            machine_id = self._get_or_create_fallback_id()
        return machine_id

    def _get_or_create_fallback_id(self) -> str:
        """Get or create a persistent random machine ID."""
        config = self._load_config_raw()
        fallback_id = config.get("_machine_id")
        if not fallback_id:
            # Generate a cryptographically secure random ID
            fallback_id = secrets.token_hex(32)
            config["_machine_id"] = fallback_id
            self._save_config_raw(config)
        return fallback_id

    def _get_or_create_salt(self) -> bytes:
        """Get or create installation-specific salt."""
        config = self._load_config_raw()
        salt_hex = config.get("_salt")
        if not salt_hex:
            # Generate cryptographically secure random salt
            salt = secrets.token_bytes(SALT_LENGTH)
            config["_salt"] = salt.hex()
            try:
                self._save_config_raw(config)
            except Exception as e:
                logger.error(f"Failed to save salt: {e}")
                raise RuntimeError("Cannot initialize encryption - failed to save salt") from e
            # Verify salt was persisted
            verify_config = self._load_config_raw()
            if verify_config.get("_salt") != salt.hex():
                raise RuntimeError("Cannot initialize encryption - failed to save salt")
            return salt
        return bytes.fromhex(salt_hex)

    def _create_fernet(self) -> Fernet:
        """Create Fernet instance with machine-specific key and random salt."""
        machine_id = self._get_machine_id()
        salt = self._get_or_create_salt()

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(machine_id.encode()))
        return Fernet(key)

    def _get_fernet(self) -> Fernet:
        """Get or create Fernet instance (lazy initialization)."""
        if self._fernet is None:
            self._fernet = self._create_fernet()
        return self._fernet

    def _load_config_raw(self) -> dict:
        """Load raw configuration from file (without triggering Fernet init)."""
        if not CONFIG_FILE.exists():
            return {}
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}

    def _save_config_raw(self, config: dict) -> None:
        """Save configuration to file with restricted permissions."""
        CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)

        # Write to file
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2)

        # Set restrictive file permissions
        self._set_file_permissions(CONFIG_FILE)

    def _set_file_permissions(self, file_path: Path) -> None:
        """Set restrictive file permissions (owner read/write only)."""
        try:
            if os.name == 'nt':  # Windows
                # Use icacls to restrict access to current user only
                import subprocess
                username = os.environ.get('USERNAME', '')
                if username:
                    # Remove inherited permissions and grant only current user
                    subprocess.run(
                        ['icacls', str(file_path), '/inheritance:r',
                         '/grant:r', f'{username}:(R,W)'],
                        capture_output=True,
                        creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
                    )
            else:  # Unix/Linux/macOS
                # Set permissions to 600 (owner read/write only)
                os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)
        except Exception:
            # Don't fail if permissions can't be set - log would be better
            pass

    def _load_config(self) -> dict:
        """Load configuration from file."""
        return self._load_config_raw()

    def _save_config(self, config: dict) -> None:
        """Save configuration to file."""
        self._save_config_raw(config)

    def save_api_key(self, api_key: str) -> None:
        """Encrypt and save API key."""
        fernet = self._get_fernet()
        encrypted = fernet.encrypt(api_key.encode()).decode()
        config = self._load_config()
        config["api_key"] = encrypted
        self._save_config(config)

    def load_api_key(self) -> str | None:
        """Load and decrypt API key."""
        config = self._load_config()
        encrypted = config.get("api_key")
        if not encrypted:
            return None
        try:
            fernet = self._get_fernet()
            return fernet.decrypt(encrypted.encode()).decode()
        except Exception:
            return None

    def has_api_key(self) -> bool:
        """Check if API key is stored."""
        return self.load_api_key() is not None

    def delete_api_key(self) -> None:
        """Remove stored API key."""
        config = self._load_config()
        config.pop("api_key", None)
        self._save_config(config)

    def validate_api_key(self, api_key: str) -> tuple[bool, str]:
        """
        Validate API key by making a test request to Deepgram.

        Returns:
            Tuple of (is_valid, message)
        """
        try:
            with httpx.Client(timeout=API_TIMEOUT) as client:
                response = client.get(
                    "https://api.deepgram.com/v1/projects",
                    headers={"Authorization": f"Token {api_key}"}
                )

                if response.status_code == 200:
                    return True, "API key is valid"
                elif response.status_code == 401:
                    return False, "Invalid API key"
                elif response.status_code == 403:
                    return False, "Access denied for this API key"
                else:
                    return False, f"API error: {response.status_code}"

        except httpx.TimeoutException:
            return False, "Timeout - check your internet connection"
        except httpx.RequestError as e:
            return False, f"Connection error: {str(e)}"

    def get_balance(self) -> Optional[dict]:
        """
        Get the account balance from Deepgram API.

        Returns:
            Dictionary with 'amount' and 'units' keys, or None if error.
            Returns {'error': message} if API call fails.
        """
        api_key = self.load_api_key()
        if not api_key:
            return None

        try:
            with httpx.Client(timeout=30) as client:
                # First, get the project ID
                projects_response = client.get(
                    "https://api.deepgram.com/v1/projects",
                    headers={"Authorization": f"Token {api_key}"}
                )

                if projects_response.status_code != 200:
                    return {"error": f"Failed to get projects: {projects_response.status_code}"}

                projects_data = projects_response.json()
                projects = projects_data.get("projects", [])

                if not projects:
                    return {"error": "No projects found"}

                # Use the first project
                project_id = projects[0].get("project_id")
                if not project_id:
                    return {"error": "Project ID not found"}

                # Get balances for the project
                balances_response = client.get(
                    f"https://api.deepgram.com/v1/projects/{project_id}/balances",
                    headers={"Authorization": f"Token {api_key}"}
                )

                if balances_response.status_code != 200:
                    return {"error": f"Failed to get balance: {balances_response.status_code}"}

                balances_data = balances_response.json()
                balances = balances_data.get("balances", [])

                if not balances:
                    return {"amount": 0, "units": "usd"}

                # Sum all balances
                total_amount = 0
                units = "usd"

                for balance in balances:
                    amount = balance.get("amount", 0)
                    total_amount += amount
                    units = balance.get("units", "usd")

                return {"amount": total_amount, "units": units}

        except httpx.TimeoutException:
            return {"error": "Timeout"}
        except httpx.RequestError as e:
            return {"error": str(e)}
        except Exception as e:
            return {"error": str(e)}

    def get_preference(self, key: str, default=None):
        """Get a user preference."""
        config = self._load_config()
        return config.get("preferences", {}).get(key, default)

    def set_preference(self, key: str, value) -> None:
        """Set a user preference."""
        config = self._load_config()
        if "preferences" not in config:
            config["preferences"] = {}
        config["preferences"][key] = value
        self._save_config(config)

    def get_model(self) -> str:
        """Get the selected Deepgram model."""
        return self.get_preference("model", DEEPGRAM_DEFAULT_MODEL)

    def set_model(self, model: str) -> None:
        """Set the Deepgram model."""
        self.set_preference("model", model)

    def get_specialization(self) -> str:
        """Get the selected model specialization."""
        return self.get_preference("specialization", DEEPGRAM_DEFAULT_SPECIALIZATION)

    def set_specialization(self, specialization: str) -> None:
        """Set the model specialization."""
        self.set_preference("specialization", specialization)

    def get_model_string(self, language: str = "en") -> str:
        """Get the full model string for Deepgram API (e.g., 'nova-2-meeting').

        Specializations only work with English. For other languages,
        returns the base model (e.g., 'nova-2' instead of 'nova-2-video').
        """
        model = self.get_model()
        specialization = self.get_specialization()

        # Specializations only work with English
        if specialization == "general" or language != "en":
            return model
        return f"{model}-{specialization}"
